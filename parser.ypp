%{
    #include <iostream>
    #include <stdlib.h> /* For malloc in symbol table */
    #include <string.h> /* For strcmp in symbol table */
    #include <stdio.h> /* For error messages */
    #include <stack>
    #include "ST.h"
    // #include "CG.h"
    // #define YYDEBUG 1
    int yylex();
    void yyerror(const char *);
    int count = 0;

    void install (char* sym_name){
        symrec* s;
        s = getsym(sym_name);
        if (s == 0){
            s = putsym(sym_name);
            // printf("STORE %d\n", s->pos);
        }
        else{
            // errors++;
            printf("error: %s is already defined\n", sym_name);
        }
    }

    std::stack<symrec*> identifiers;
    std::stack<int> values;

    void context_check(char* sym_name){
        symrec* identifier;
        identifier = getsym(sym_name);
        if (identifier == 0){
            // errors++;
            printf("error: %s is an undeclared identifier\n", sym_name);
        }
        else {
            identifiers.push(identifier);
        }
    }

    void assign(){
        // printf("zaÅ‚aduj %d do a{\n", values.top());
        printf("RESET a\n");
        int value = values.top();
        if (std::abs(value) > 10){

        }
        else {
            const char* cmd = (value > 0 ? "INC" : "DEC"); 
            for (int i = 0; i < value; i++){
                printf("%s a\n", cmd);
            }
        }
        printf("RESET h\n");
        for (int i = 0; i < identifiers.top()->pos; i++){
            printf("INC h\n");
        }
        printf("STORE h\n");
        identifiers.pop();
        values.pop();
    }
%}

%union semrec /* The Semantic Records */
{
    int num; /* Integer values */
    char* pidentifier; /* Identifiers */
    struct lbs* lbls; /* For backpatching */
}

%token VAR _BEGIN END ASSIGN IF THEN ELSE ENDIF
%token WHILE DO ENDDO ENDWHILE FOR FROM TO DOWNTO ENDFOR REPEAT UNTIL
%token READ WRITE
%left PLUS MINUS 
%left TIMES DIV MOD
%token EQ NEQ LE GE LEQ GEQ


%token <pidentifier> pidentifier
%token <num> num

%%
program:
        VAR declarations _BEGIN commands END {/*printSym();*/printf("RESET h\nINC h\nINC h\nLOAD h\nPUT\n"); printf("HALT\n");}
    |   _BEGIN commands END 
;
declarations:
        declarations ',' pidentifier    {install($3);}
    |   declarations ',' pidentifier '[' num ':' num ']'
    |   pidentifier {install($1);}
    |   pidentifier '[' num ':' num ']'
;
commands:
        commands command
    |   command
;
command:
        identifier ASSIGN expression ';' {assign();}
    |   IF condition THEN commands ELSE commands ENDIF
    |   IF condition THEN commands ENDIF
    |   WHILE condition DO commands ENDWHILE
    |   REPEAT commands UNTIL condition ';'
    |   FOR pidentifier FROM value TO value DO commands ENDFOR
    |   FOR pidentifier FROM value DOWNTO value DO commands ENDFOR
    |   READ identifier ';'
    |   WRITE value ';'
;
expression:
        value
    |   value PLUS value {int temp = values.top(); values.pop(); temp += values.top(); values.pop(); values.push(temp);}
    |   value MINUS value {int temp = -values.top(); values.pop(); temp += values.top(); values.pop(); values.push(temp);}
    |   value TIMES value {int temp = values.top(); values.pop(); temp *= values.top(); values.pop(); values.push(temp);}
    |   value DIV value {int temp = values.top(); values.pop(); temp = values.top() / temp; values.pop(); values.push(temp);}
    |   value MOD value {int temp = values.top(); values.pop(); temp = values.top() % temp; values.pop(); values.push(temp);}
;
condition:
        value EQ value
    |   value NEQ value
    |   value LE value
    |   value GE value
    |   value LEQ value
    |   value GEQ value
;
value:
        num     {values.push($1);}
    |   identifier
;
identifier:
        pidentifier  {context_check($1);}
    |   pidentifier '[' pidentifier ']'
    |   pidentifier '[' num ']'
;
%%

int main(){
    // yydebug = 1;
    return yyparse();
}

void yyerror(const char* err){
    std::cout << "Error: " << err << std::endl;
}